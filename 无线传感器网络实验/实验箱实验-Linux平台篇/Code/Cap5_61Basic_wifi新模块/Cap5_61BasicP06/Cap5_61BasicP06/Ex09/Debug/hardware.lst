Generalplus u'nSP Assembler - Ver. 1.14.13.0
              Listing File Has Been Relocated
                            	//========================================================================================
                            	// Progarm: Standard function definition
                            	// Writen by: Andy
                            	// Modifiyed: by Arthur Shieh
                            	//
                            	// Lastest modified date: 
                            	// 		2000/06/23: first version
                            	//		2000/07/15: modified
                            	//		2000/07/24: modified					for sacmv25.lib
                            	//		2001/10/03: Add more public about queue for sacmv25f.lib
                            	// 		2001/11/05: Independent Queue for A2000/S480/MS01 Manual Mode - sacmv25h.lib
                            	//		2001/11/06: Fix volume parameter problem - sacmv25i.lib
                            	//      2002/05/26: Modified the length of C_QueueSize to 144 for DVR usage
                            	//      2005/10/20: Modified for SACMV26e.lib    by Xinqiang Zhang
                            	//
                            	// For: sacmV26e.lib
                            	//
                            	// Note: 
                            	//  1. Don't change this file if possible.
                            	//  2. Update hardware.inc with hardware.asm synchorously
                            	//	3. Provide Open code for sacmV26e.lib
                            	//
                            	//========================================================================================
                            	
                            	.PUBLIC	F_SP_RampUpDAC1
                            	.PUBLIC	F_SP_RampDnDAC1
                            	.PUBLIC	F_SP_RampUpDAC2
                            	.PUBLIC	F_SP_RampDnDAC2
                            	.PUBLIC	_SP_RampUpDAC1 
                            	.PUBLIC	_SP_RampDnDAC1 
                            	.PUBLIC	_SP_RampUpDAC2 
                            	.PUBLIC	_SP_RampDnDAC2 
                            	
                            	.PUBLIC	_SP_InitQueue
                            	.PUBLIC	_SP_InitQueue_A2000
                            	.PUBLIC	_SP_InitQueue_S480
                            	.PUBLIC	_SP_InitQueue_S240
                            	.PUBLIC	_SP_InitQueue_MS01
                            	.PUBLIC	_SP_InitQueue_DVR
                            	
                            	.PUBLIC	F_SP_InitQueue
                            	.PUBLIC	F_SP_InitQueue_A2000
                            	.PUBLIC	F_SP_InitQueue_S480
                            	.PUBLIC	F_SP_InitQueue_S240
                            	.PUBLIC	F_SP_InitQueue_MS01
                            	.PUBLIC	F_SP_InitQueue_DVR
                            	
                            	.PUBLIC	F_SP_ReadQueue
                            	.PUBLIC F_SP_ReadQueue_A2000
                            	.PUBLIC F_SP_ReadQueue_S480
                            	.PUBLIC F_SP_ReadQueue_S240
                            	.PUBLIC F_SP_ReadQueue_MS01
                            	.PUBLIC F_SP_ReadQueue_DVR
                            	
                            	.PUBLIC	F_SP_ReadQueue_NIC			// Read Queue with no index change
                            	.PUBLIC	F_SP_ReadQueue_NIC_A2000
                            	.PUBLIC	F_SP_ReadQueue_NIC_S480
                            	.PUBLIC	F_SP_ReadQueue_NIC_S240
                            	.PUBLIC	F_SP_ReadQueue_NIC_MS01
                            	.PUBLIC	F_SP_ReadQueue_NIC_DVR
                            	
                            	.PUBLIC	F_SP_WriteQueue
                            	.PUBLIC F_SP_WriteQueue_A2000
                            	.PUBLIC F_SP_WriteQueue_S480
                            	.PUBLIC F_SP_WriteQueue_S240
                            	.PUBLIC F_SP_WriteQueue_MS01
                            	.PUBLIC F_SP_WriteQueue_DVR
                            	
                            	.PUBLIC F_SP_TestQueue
                            	.PUBLIC F_SP_TestQueue_A2000
                            	.PUBLIC F_SP_TestQueue_S480
                            	.PUBLIC F_SP_TestQueue_S240
                            	.PUBLIC F_SP_TestQueue_MS01
                            	.PUBLIC F_SP_TestQueue_DVR
                            	
                            	.PUBLIC _SP_Export  
                            	.PUBLIC	_SP_Import 
                            	.PUBLIC _SP_Init_IOB 
                            	.PUBLIC _SP_Init_IOA 
                            	
                            	.PUBLIC	_SP_GetResource	
                            	.PUBLIC F_SP_GetResource
                            	
                            	.PUBLIC F_SP_SACM_A2000_Init_
                            	.PUBLIC F_SP_SACM_S480_Init_
                            	.PUBLIC F_SP_SACM_S240_Init_
                            	
                            	.PUBLIC F_SP_SACM_MS01_Init_
                            	.PUBLIC F_SP_PlayMode0_
                            	.PUBLIC F_SP_PlayMode1_    
                            	.PUBLIC F_SP_PlayMode2_  
                            	.PUBLIC F_SP_PlayMode3_   
                            	
                            	.PUBLIC F_SP_SACM_DVR_Init_
                            	.PUBLIC F_SP_SACM_DVR_Rec_Init_
                            	.PUBLIC F_SP_SACM_DVR_Play_Init_
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Definitions for I/O Port
                            	//////////////////////////////////////////////////////////////////
                            	.DEFINE	P_IOA_Data   		0x7000         // Write Data into data register and read from IOA pad
                            	.DEFINE P_IOA_Buffer        0x7001         // Write Data into buffer register and read from buffer register
                            	.DEFINE P_IOA_Dir           0x7002         // Direction vector for IOA
                            	.DEFINE P_IOA_Attrib        0x7003         // Attribute vector for IOA
                            	.DEFINE P_IOA_Latch         0x7004         // Latch PortA data for key change wake-up
                            	
                            	.DEFINE P_IOB_Data         	0x7005         // Write Data into the data register and read from IOB pad
                            	.DEFINE P_IOB_Buffer        0x7006         // Write Data into buffer register and read from buffer register
                            	.DEFINE P_IOB_Dir           0x7007         // Direction vector for IOB
                            	.DEFINE P_IOB_Attrib        0x7008         // Attribute vector for IOB
                            	
                            	.DEFINE P_FeedBack          0x7009         // Clock form external R,C
                            	.DEFINE P_TimerA_Data       0x700A         // Data port for TimerA 
                            	.DEFINE P_TimerA_Ctrl       0x700B         // Control Port for TimerA
                            	.DEFINE P_TimerB_Data       0x700C         // Data port for TimerB
                            	.DEFINE P_TimerB_Ctrl       0x700D         // Control Port for TimerB
                            	.DEFINE P_TimeBase_Setup    0x700E         // TimerBase Freq. Set
                            	.DEFINE P_TimeBase_Clear	0x700F 		   // Reset Timerbase counter
                            	.DEFINE P_INT_Ctrl          0x7010         // Control port for interrupt source
                            	.DEFINE P_INT_Clear         0x7011         // Clear interrupt source
                            	.DEFINE P_Watchdog_Clear    0x7012         // Watchdog Reset
                            	.DEFINE P_SystemClock       0x7013         // Change system clock frequency(include go to standby mode)
                            	
                            	//... PA6442 New version MC52A (For EC-03)....
                            	.DEFINE P_ADC 	        	0x7014         	// Data Port for AD
                            	.DEFINE P_ADC_Ctrl          0x7015         	// Control Port for AD control
                            	.DEFINE P_ADC_Status        0x7015         	// AD Port Status
                            	.DEFINE P_DAC2              0x7016         	// Data Port for DAC2
                            	.DEFINE P_PWM               0x7016         	// Data Port for PWM
                            	.DEFINE P_DAC1	        	0x7017         	// Data Port for DAC1
                            	.DEFINE P_DAC_Ctrl			0x702A 			// Control Port for two DAC and audio output mode
                            	//............................................
                            	
                            	.DEFINE P_IR_Ctrl			0x7018 			// Control Port for IR
                            	.DEFINE P_LVD_Ctrl          0x7019         	// Control Port for LVD
                            	.DEFINE P_SIO_Data			0x701A 			// Data port for serial IO
                            	.DEFINE P_SIO_Addr_Low		0x701B 			// Address Port low
                            	.DEFINE P_SIO_Addr_Mid		0x701C 			// Address Port middle
                            	.DEFINE P_SIO_Addr_High	 	0x701D 			// Address Port high
                            	.DEFINE P_SIO_Ctrl			0x701E 			// Control Port
                            	.DEFINE P_SIO_Start			0x701F 			// Start port for serial interface
                            	.DEFINE P_SIO_Stop			0x7020 			// Stop port for serial interface
                            	
                            	.DEFINE P_UART_Command1		 0x7021 		// Command1 Port for UART
                            	.DEFINE P_UART_Command2		 0x7022 		// Command2 Port for UART
                            	.DEFINE P_UART_Data			 0x7023  		// Data Port for UART
                            	.DEFINE	P_UART_BaudScalarLow 0x7024 		// Set Baud Rate scalar low
                            	.DEFINE	P_UART_BaudScalarHigh 0x7025 		// Set Baud Rate scalar high
                            	
                            	
                            	//... Definitions for P_INT_Ctrl ..............
                            	.DEFINE C_IRQ6_TMB2             0x0001         	// Timer B IRQ6
                            	.DEFINE C_IRQ6_TMB1             0x0002         	// Timer A IRQ6
                            	.DEFINE C_IRQ5_2Hz              0x0004         	// 2Hz IRQ5
                            	.DEFINE C_IRQ5_4Hz              0x0008         	// 4Hz IRQ5
                            	.DEFINE C_IRQ4_1KHz             0x0010         	// 1024Hz IRQ4
                            	.DEFINE C_IRQ4_2KHz             0x0020         	// 2048Hz IRQ4
                            	.DEFINE C_IRQ4_4KHz             0x0040         	// 4096Hz IRQ4
                            	.DEFINE C_IRQ3_KEY              0x0080         	// Key Change IRQ3
                            	.DEFINE C_IRQ3_EXT1             0x0100         	// Ext1 IRQ3
                            	.DEFINE C_IRQ3_EXT2             0x0200         	// Ext2 IRQ3
                            	.DEFINE C_IRQ2_TMB              0x0400         	// Timer B IRQ2
                            	.DEFINE C_FIQ_TMB               0x0800         	// Timer B FIQ
                            	.DEFINE C_IRQ1_TMA              0x1000         	// Timer A IRQ1
                            	.DEFINE C_FIQ_TMA               0x2000         	// Timer A FIQ
                            	.DEFINE C_IRQ0_PWM              0x4000         	// PWM IRQ0
                            	.DEFINE C_FIQ_PWM               0x8000         	// PWM FIQ
                            	
                            	// Definitions for P_TimerA/B_Ctrl ............                               
                            	.DEFINE	C_Fosc_2				0x0000 			// 
                            	.DEFINE	C_Fosc_256		    	0x0001 			//
                            	.DEFINE	C_32768Hz				0x0002 			//
                            	.DEFINE	C_8192Hz				0x0003 			//
                            	.DEFINE	C_4096Hz				0x0004 			//
                            	.DEFINE	C_A1					0x0005 			//
                            	.DEFINE C_A0					0x0006 			//
                            	.DEFINE C_Ext1					0x0007 			//
                            	
                            	.DEFINE	C_2048Hz				0x0000 			//
                            	.DEFINE	C_1024Hz				0x0008 			//
                            	.DEFINE	C_256Hz					0x0010 			//
                            	.DEFINE	C_TMB1Hz				0x0018 			//
                            	.DEFINE	C_4Hz					0x0020 			//
                            	.DEFINE	C_2Hz					0x0028 			//
                            	.DEFINE	C_B1					0x0030 			//
                            	.DEFINE	C_Ext2					0x0038 			//
                            	
                            	.DEFINE	C_Off					0x0000 			//
                            	.DEFINE C_D1					0x0040 			//
                            	.DEFINE C_D2					0x0080 			//
                            	.DEFINE C_D3					0x00C0 			//
                            	.DEFINE C_D4					0x0100 			//
                            	.DEFINE C_D5					0x0140 			//
                            	.DEFINE C_D6					0x0180 			//
                            	.DEFINE C_D7					0x01C0 			//
                            	.DEFINE C_D8					0x0200 			//
                            	.DEFINE C_D9					0x0240 			//
                            	.DEFINE C_D10					0x0280 			//
                            	.DEFINE C_D11					0x02C0 			//
                            	.DEFINE C_D12					0x0300 			//
                            	.DEFINE C_D13					0x0340 			//
                            	.DEFINE C_D14					0x0380 			//
                            	.DEFINE C_TA_Div_2				0x03C0 			// Timer A
                            	.DEFINE C_TB_Div_2				0x03C0 			// Timer B
                            	
                            	//... Definition for P_SystemClock ............
                            	.DEFINE C_Fosc					0x0000 			// b3..b0
                            	.DEFINE C_Fosc_Div_2			0x0001 			//
                            	.DEFINE C_Fosc_Div_4			0x0002 			//
                            	.DEFINE C_Fosc_Div_8			0x0003 			// (default)
                            	.DEFINE C_Fosc_Div_16			0x0004 			//
                            	.DEFINE C_Fosc_Div_32			0x0005 			//
                            	.DEFINE C_Fosc_Div_64			0x0006 			//
                            	.DEFINE C_Sleep					0x0007 		 	//
                            	
                            	.DEFINE	C_32K_Work				0x0000 			// b4
                            	.DEFINE C_32K_Off				0x0000 			// 
                            	.DEFINE C_StrongMode			0x0000 			// b5
                            	.DEFINE C_AutoMode				0x0000 			//
                            	
                            	//... Define for P_AD_Ctrl ....................
                            	.DEFINE	C_AD					0x0001 			//
                            	.DEFINE C_DA					0x0000 			//
                            	.DEFINE C_MIC					0x0000 			//
                            	.DEFINE C_LINE					0x0002 			//
                            	
                            	//... Define for P_DA_Ctrl ....................
                            	.DEFINE C_PushPull				0x0000 			// b0, (default) 
                            	.DEFINE C_DoubleEnd				0x0001 			// b0
                            	.DEFINE	C_DAC_Mode				0x0000 			// b1, (default)
                            	.DEFINE C_PWM_Mode				0x0002 			// b1
                            	
                            	.DEFINE	C_D1_Direct				0x0000 			// DAC1 latch
                            	.DEFINE C_D1_LatchA				0x0008 			// 
                            	.DEFINE C_D1_LatchB				0x0010 			//
                            	.DEFINE C_D1_LatchAB			0x0018 			//
                            	
                            	.DEFINE	C_D2_Direct				0x0000 			// DAC2 latch
                            	.DEFINE C_D2_LatchA				0x0020 			// 
                            	.DEFINE C_D2_LatchB				0x0040 			//
                            	.DEFINE C_D2_LatchAB			0x00C0 			//
                            	
                            	//... Define for P_LVD_Ctrl ...................
                            	.DEFINE C_LVD24V				0x0000 			// LVD = 2.4V 
                            	.DEFINE C_LVD28V				0x0001 			// LVD = 2.8V
                            	.DEFINE C_LVD32V				0x0002 			// LVD = 3.2V
                            	.DEFINE C_LVD36V				0x0003 			// LVD = 3.6V
                            	
                            	
                            	
                            	/////////////////////////////////////////////////////////////////
                            	// Note: This register map to the P_INT_Ctrl(0x7010)
                            	// 	User's interrupt setting have to combine with this register 
                            	//	while co-work with SACM library.
                            	//
                            	//  See. following function for example:
                            	//	F_SP_SACM_A2000_Init_:
                            	//	F_SP_SACM_S480_Init_:
                            	//	F_SP_SACM_S240_Init_:
                            	//	F_SP_SACM_MS01_Init_:
                            	//	F_SP_SACM_DVR_Init_: 
                            	//////////////////////////////////////////////////
000004D2                    	.IRAM
                            	//.PUBLIC	R_InterruptStatus 
                            	//.VAR	R_InterruptStatus = C_IRQ5_4Hz |C_IRQ3_EXT1 //这个地方需要注意			
                            	
                            	//////////////////////////////////////////////////
                            	
                            	.DEFINE C_RampDelayTime 32
                            	.DEFINE C_QueueSize 144
                            			
000004D2 00 00              	.VAR 	R_Queue 
000004D3 00 00 00 00        	.DW		C_QueueSize-1	DUP(0) 
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00 00 00
         00 00      
00000562 00 00              	.VAR	R_ReadIndex 
00000563 00 00              	.VAR	R_WriteIndex 
                            	
0000A8B3                    	.CODE
                            	
                            					
                            	
                            	///////////////////////////////////////////
                            	// Function: Initial Queue
                            	// Destory: R1,r2
                            	///////////////////////////////////////////	
                            	_SP_InitQueue:	.PROC
                            	_SP_InitQueue_A2000:
                            	_SP_InitQueue_S480:
                            	_SP_InitQueue_S240:
                            	_SP_InitQueue_MS01:
                            	_SP_InitQueue_DVR:
                            	
                            	F_SP_InitQueue_A2000:
                            	F_SP_InitQueue_S480:
                            	F_SP_InitQueue_S240:
                            	F_SP_InitQueue_MS01:
                            	F_SP_InitQueue_DVR:
                            	F_SP_InitQueue:
0000A8B3 09 93 D2 04        			r1 = R_Queue
0000A8B5 40 94              			r2 = 0 
                            	L_ClearQueueLoop?:		
0000A8B6 D1 D4              			[r1++] = r2
0000A8B7 09 43 62 05        			cmp	r1, R_Queue+C_QueueSize
0000A8B9 44 4E              			jne	L_ClearQueueLoop?
                            				
0000A8BA 40 92              			r1 = 0
0000A8BB 19 D3 62 05        			[R_ReadIndex] = r1
0000A8BD 19 D3 63 05        			[R_WriteIndex] = r1
                            					
0000A8BF 90 9A              			RETF
                            			.ENDP
                            			
                            	///////////////////////////////////////////
                            	// Function: Get a data form Queue
                            	// Output:  R1: Data
                            	//			R2: return value
                            	// Destory: R1,R2
                            	///////////////////////////////////////////	
                            	F_SP_ReadQueue_A2000:
                            	F_SP_ReadQueue_S480:
                            	F_SP_ReadQueue_S240:
                            	F_SP_ReadQueue_MS01:
                            	F_SP_ReadQueue_DVR:
                            	F_SP_ReadQueue:
0000A8C0 12 95 62 05        			r2 = [R_ReadIndex]
0000A8C2 12 45 63 05        			cmp r2,[R_WriteIndex]
0000A8C4 0D 5E              			je	L_RQ_QueueEmpty
                            	
0000A8C5 0A 05 D2 04        			r2 += R_Queue				// get queue data address
0000A8C7 C2 92              			r1 = [r2]
                            			
0000A8C8 12 95 62 05        			r2 = [R_ReadIndex]
0000A8CA 41 04              			r2 += 1
0000A8CB 0A 45 90 00        			cmp	r2, C_QueueSize
0000A8CD 01 4E              			jne	L_RQ_NotQueueBottom
0000A8CE 40 94              			r2 = 0
                            	L_RQ_NotQueueBottom:	
0000A8CF 1A D5 62 05        			[R_ReadIndex] = r2		
                            			//r2 = 0x0000 						// get queue data
0000A8D1 90 9A              			retf 
                            	L_RQ_QueueEmpty:
                            			//r2 = 0x8000 						// queue empty
0000A8D2 90 9A              			retf 
                            	
                            	///////////////////////////////////////////
                            	// Function: Get a data from Queue but do 
                            	//			not change queue index
                            	// R1: output
                            	// Destory: R1,R2
                            	///////////////////////////////////////////
                            	F_SP_ReadQueue_NIC:
                            	F_SP_ReadQueue_NIC_A2000:
                            	F_SP_ReadQueue_NIC_S480:
                            	F_SP_ReadQueue_NIC_S240:
                            	F_SP_ReadQueue_NIC_MS01:
                            	F_SP_ReadQueue_NIC_DVR:
0000A8D3 12 95 62 05        			r2 = [R_ReadIndex]
0000A8D5 12 45 63 05        			cmp r2,[R_WriteIndex]
0000A8D7 03 5E              			je	L_RQ_QueueEmpty?
                            	
0000A8D8 0A 05 D2 04        			r2 += R_Queue				// get queue data index
0000A8DA C2 92              			r1 = [r2]
                            	L_RQ_QueueEmpty?:
0000A8DB 90 9A              			RETF
                            			
                            	///////////////////////////////////////////
                            	// Function: Put a data to Queue
                            	// R1: Input
                            	// Destory: R1,R2
                            	///////////////////////////////////////////	
                            	F_SP_WriteQueue_A2000:
                            	F_SP_WriteQueue_S480:
                            	F_SP_WriteQueue_S240:
                            	F_SP_WriteQueue_MS01:
                            	F_SP_WriteQueue_DVR:
                            	F_SP_WriteQueue:
0000A8DC 12 95 63 05        			r2 = [R_WriteIndex] 			// put data to queue
0000A8DE 0A 05 D2 04        			r2 += R_Queue
0000A8E0 C2 D2              			[r2] = r1
                            	
0000A8E1 12 95 63 05        			r2 = [R_WriteIndex]
0000A8E3 41 04              			r2 += 1
0000A8E4 0A 45 90 00        			cmp	r2, C_QueueSize
0000A8E6 01 4E              			jne	L_WQ_NotQueueBottom
0000A8E7 40 94              			r2 = 0
                            	L_WQ_NotQueueBottom:
0000A8E8 1A D5 63 05        			[R_WriteIndex] = r2
0000A8EA 90 9A              			RETF
                            	
                            			
                            	///////////////////////////////////////////
                            	// Function: Test Queue Status
                            	// o/p: R1
                            	// Destory: R1
                            	///////////////////////////////////////////	
                            	F_SP_TestQueue_A2000:
                            	F_SP_TestQueue_S480:
                            	F_SP_TestQueue_S240:
                            	F_SP_TestQueue_MS01:
                            	F_SP_TestQueue_DVR:
                            	F_SP_TestQueue:
                            			//... Test Queue Empty ...
0000A8EB 11 93 62 05        			r1 = [R_ReadIndex] 
0000A8ED 11 43 63 05        			cmp r1,[R_WriteIndex] 
0000A8EF 12 5E              			je	L_TQ_QueueEmpty 
                            	
                            			//... Test Queue Full ...
0000A8F0 11 93 62 05        			r1 = [R_ReadIndex] 				// For N Queue Full: 1.R=0 and W=N-1 2. R<>0 and W=R-1 
0000A8F2 05 4E              			jnz	L_TQ_JudgeCond2 
0000A8F3 11 93 63 05        			r1 = [R_WriteIndex] 
0000A8F5 09 43 8F 00        			cmp	r1, C_QueueSize-1 			// Cond1
0000A8F7 08 5E              			je	L_TQ_QueueFull 			
                            	L_TQ_JudgeCond2:		
0000A8F8 11 93 62 05        			r1 = [R_ReadIndex] 
0000A8FA 41 22              			r1 -=1 
0000A8FB 11 43 63 05        			cmp r1,[R_WriteIndex] 
0000A8FD 02 5E              			je	L_TQ_QueueFull 	
                            	
0000A8FE 40 92              			r1 = 0 							// not Full, not empty
0000A8FF 90 9A              			retf 
                            	L_TQ_QueueFull:
0000A900 41 92              			r1 = 1 							// full
0000A901 90 9A              			retf 
                            	L_TQ_QueueEmpty:
0000A902 42 92              			r1 = 2 							// empty
0000A903 90 9A              			retf 
                            	
                            	
                            	
                            	
                            	
                            	///////////////////////////////////////////////////////////////////////////////
                            	// Function: The partial code of hardware setting of SACM_A2000_Initial() 
                            	//			or F_SACM_A2000_Initial:
                            	// Note: The following functions are the partial code of original
                            	//			initial subroutine. (H/W setting part) 
                            	//
                            	//	Ex: F_SACM_A2000_Initial:
                            	//			...
                            	//			call F_SP_SACM_A2000_Init_	: S480/S240/MS01 is same
                            	//			...
                            	//			retf
                            	////////////////////////////////////////////////////////////////////////////////
                            	F_SP_SACM_A2000_Init_:	
0000A904 40 92              			r1=0x0000;                      // 24MHz, Fcpu=Fosc
0000A905 19 D3 13 70        	        [P_SystemClock]=r1           	//  Frequency 20MHz
0000A907 70 92              	        r1 = 0x0030                     // TimerA CKA=Fosc/2 CKB=1 Tout:off
0000A908 19 D3 0B 70        	        [P_TimerA_Ctrl] = r1			// Initial Timer A
0000A90A 09 93 00 FD        	        r1 = 0xfd00                  	// 16K
0000A90C 19 D3 0A 70        	        [P_TimerA_Data] = r1 
0000A90E 09 93 A8 00        	        r1 = 0x00A8                     // Set the DAC Ctrl
0000A910 19 D3 2A 70        	        [P_DAC_Ctrl] = r1
0000A912 09 93 FF FF        	        r1 = 0xffff
                            	        
0000A914 19 D3 11 70        	        [P_INT_Clear] = r1          	// Clear interrupt occuiped events
0000A916 40 92              	        r1 =0x0000						// 
                            	        
                            	        
0000A917 11 93 2D 70        	        r1 = [0x702D]		//
0000A919 09 A3 00 20        	        r1 |= C_FIQ_TMA					// Enable Timer A FIQ
                            	        //R1 |= C_IRQ4_1KHz
0000A91B 19 D3 2D 70        	        [0x702D] = r1		//
0000A91D 19 D3 10 70        	        [P_INT_Ctrl] = r1				//
                            	
0000A91F 90 9A              			RETF
                            	
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: The partial code of hardware setting of SACM_S480_Initial() 
                            	//			or F_SACM_S480_Initial:
                            	//////////////////////////////////////////////////////////////////
                            	F_SP_SACM_S480_Init_:
                            	//        r1 = 0x0000						// 24MHz Fosc
                            	//        [P_SystemClock]=r1          	// Initial System Clock
0000A920 70 92              	        r1=0x0030                       // TimerA CKA=Fosc/2 CKB=1 Tout:off
0000A921 19 D3 0B 70        	        [P_TimerA_Ctrl]=r1				// Initial Timer A
                            	        //R1 = 0xfd00                  	// 16K
                            	        //r1 = 0xfced						// 15.625K
0000A923 09 93 00 FA        	        r1 = 0xFA00						//这个值是修改过的，主要是和产生PWM的始终频率一致而做
0000A925 19 D3 0A 70        	        [P_TimerA_Data]=r1
0000A927 09 93 A8 00        	        r1 = 0x00A8						// 
0000A929 19 D3 2A 70        	        [P_DAC_Ctrl] = r1				//
                            	        
0000A92B 09 93 FF FF        	        r1 = 0xffff
0000A92D 19 D3 11 70        	        [P_INT_Clear] = r1          	// Clear interrupt occuiped events
0000A92F 11 93 2D 70        	        R1 = [0x702D]		//
0000A931 09 A3 00 10        	        r1 |= C_IRQ1_TMA					// Enable Timer A FIQ
                            	        //R1 |= C_IRQ4_1KHz				// Enable 1KHz IRQ4 for S480 decoder
0000A933 19 D3 2D 70        	        [0x702D] = r1		//
0000A935 19 D3 10 70        	        [P_INT_Ctrl] = r1				//
                            	        
0000A937 90 9A              	        RETF
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: The partial code of hardware setting of SACM_S240_Initial() 
                            	//			or F_SACM_S240_Initial:
                            	//////////////////////////////////////////////////////////////////
                            	F_SP_SACM_S240_Init_:	
0000A938 60 92              			r1=0x0020;	
0000A939 19 D3 13 70        			[P_SystemClock]=r1
0000A93B 09 93 A8 00        			r1 = 0x00A8;					// 
0000A93D 19 D3 2A 70        			[P_DAC_Ctrl]= r1
0000A93F 70 92              			r1 = 0x0030;               	// TimerA CKA=Fosc/2 CKB=1 Tout:off
0000A940 19 D3 0B 70        	        [P_TimerA_Ctrl] = r1;
0000A942 09 93 00 FE        			r1 = 0xfe00;                    // 24K
0000A944 19 D3 0A 70        	    	[P_TimerA_Data] = r1;		
0000A946 09 93 FF FF        	        r1 = 0xffff
0000A948 19 D3 11 70        	        [P_INT_Clear] = r1          	// Clear interrupt occuiped events
0000A94A 11 93 2D 70        	        r1 = [0x702D]		//
0000A94C 09 A3 00 20        	        r1 |= C_FIQ_TMA					// Enable Timer A FIQ
0000A94E 19 D3 2D 70        	        [0x702D] = r1		//
0000A950 19 D3 10 70        	        [P_INT_Ctrl] = r1				//
0000A952 90 9A              	        RETF
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Function: The partial code of hardware setting of SACM_MS01_Initial() 
                            	//			or F_SACM_MS01_Initial:
                            	//
                            	//	Ex: F_SACM_MS01_Initial:
                            	//			...
                            	//			call F_SP_SACM_MS01_Init_
                            	//			call F_SP_Play_Mode0/1/2/3	->0,1,2,3 depending on the para1
                            	//			...
                            	//			retf
                            	//////////////////////////////////////////////////////////////////
                            	F_SP_SACM_MS01_Init_:	
0000A953 40 92              			r1 = 0x0000;                    // 24MHz, Fcpu=Fosc
0000A954 19 D3 13 70        	        [P_SystemClock] = r1;        	// Initial System Clock
0000A956 70 92              	        r1 = 0x0030;                    // TimerA CKA=Fosc/2 CKB=1 Tout:off
0000A957 19 D3 0B 70        	        [P_TimerA_Ctrl] = r1			// Initial Timer A
                            	        
                            	        //R1 = 0x0003						// 8K
0000A959 40 92              	        r1 = 0x0000						// Fosc/2
0000A95A 19 D3 0D 70        	        [P_TimerB_Ctrl] = r1;			// Initial Timer B -> 8192	
                            	        
                            	        //R1 = 0xFFFF        
0000A95C 09 93 00 FA        	        r1 = 0xFA00					// Any time for ADPCM channel 0,1
0000A95E 19 D3 0C 70        	        [P_TimerB_Data] = r1			// 8K sample rate
                            	        
0000A960 09 93 FF FF        			r1 = 0xffff
0000A962 19 D3 11 70        	        [P_INT_Clear] = r1          	// Clear interrupt occuiped events
0000A964 90 9A              	        RETF
                            	
                            	//........................................
                            	F_SP_PlayMode0_:						// with F_SP_SACM_MS01_Initial
0000A965 46 92              			r1 = 0x0006
0000A966 19 D3 2A 70        	        [P_DAC_Ctrl] = r1
0000A968 09 93 00 FE        	        r1 = 0xFE00
0000A96A 19 D3 0A 70        	        [P_TimerA_Data] = r1 			//
0000A96C 11 93 2D 70        	        r1 = [0x702D] 		//
0000A96E 09 A3 10 84        	        r1 |= C_FIQ_PWM+C_IRQ2_TMB+C_IRQ4_1KHz
0000A970 19 D3 2D 70        	        [0x702D] = r1 		//
0000A972 19 D3 10 70        	        [P_INT_Ctrl] = r1				//
0000A974 90 9A              	        RETF
                            	
                            	F_SP_PlayMode1_:						// with F_SP_SACM_MS01_Initial
0000A975 09 93 A8 00        			r1 = 0x00A8
0000A977 19 D3 2A 70        	        [P_DAC_Ctrl] = r1
0000A979 09 93 00 FE        	        r1 = 0xFE00
0000A97B 19 D3 0A 70        	        [P_TimerA_Data] = r1 			//
0000A97D 11 93 2D 70        	        r1 = [0x702D] 		//
0000A97F 09 A3 10 24        	        r1 |= C_FIQ_TMA+C_IRQ2_TMB+C_IRQ4_1KHz
0000A981 19 D3 2D 70        	        [0x702D] = r1 		//
0000A983 19 D3 10 70        	        [P_INT_Ctrl] = r1				//
0000A985 90 9A              	        RETF
                            	
                            	
                            	F_SP_PlayMode2_:	 						// with F_SP_SACM_MS01_Initial
0000A986 09 93 A8 00        			r1 = 0x00A8
0000A988 19 D3 2A 70        	        [P_DAC_Ctrl] = r1
0000A98A 09 93 9A FD        	        r1 = 0xFD9A
0000A98C 19 D3 0A 70        	        [P_TimerA_Data] = r1 				//
0000A98E 11 93 2D 70        	        r1 = [0x702D] 			//
0000A990 09 A3 10 24        	        r1 |= C_FIQ_TMA+C_IRQ2_TMB+C_IRQ4_1KHz
0000A992 19 D3 2D 70        	        [0x702D] = r1 			//
0000A994 19 D3 10 70        	        [P_INT_Ctrl] = r1					//
0000A996 90 9A              	        RETF
                            	
                            	      
                            	F_SP_PlayMode3_:								// with F_SP_SACM_MS01_Initial
0000A997 09 93 A8 00        			r1 = 0x00A8
0000A999 19 D3 2A 70        	        [P_DAC_Ctrl] = r1
0000A99B 09 93 00 FD        	        r1 = 0xFD00
0000A99D 19 D3 0A 70        	        [P_TimerA_Data] = r1 					//
0000A99F 11 93 2D 70        	        r1 = [0x702D] 				//
0000A9A1 09 A3 10 24        	        r1 |= C_FIQ_TMA+C_IRQ2_TMB+C_IRQ4_1KHz
0000A9A3 19 D3 2D 70        		    [0x702D] = r1 				//
0000A9A5 19 D3 10 70        	        [P_INT_Ctrl] = r1						//
0000A9A7 90 9A              	        RETF
                            	        
                            	///////////////////////////////////////////////////////////////////////////////
                            	// Function: The partial code of hardware setting of SACM_MS01_Initial() 
                            	//			or F_SACM_MS01_Initial:
                            	//
                            	//	Ex: F_SACM_DVR_Initial:
                            	//			...
                            	//			call F_SP_SACM_DVR_Init_
                            	//			call F_SP_Play_Mode0/1/2/3	->0,1,2,3 depending on the para1
                            	//			...
                            	//			retf
                            	//	Ex1:
                            	//		F_SACM_DVR_Record: (or F_SACM_DVR_InitEncoder)
                            	//			...
                            	//			call F_SP_SACM_DVR_Rec_Init
                            	//			...
                            	//			retf
                            	//	Ex2:
                            	//		F_SACM_DVR_Play: (or F_SACM_DVR_InitDecoder)
                            	//			...
                            	//			call F_SP_SACM_DVR_Play_Init_
                            	//			...
                            	//			retf
                            	///////////////////////////////////////////////////////////////////////////////
                            	F_SP_SACM_DVR_Init_:
0000A9A8 40 92              	        r1 = 0x0000;                    // 24MHz, Fcpu=Fosc
0000A9A9 19 D3 13 70        	        [P_SystemClock] = r1;           //  Frequency 20MHz
0000A9AB 70 92              	        r1 = 0x0030;                    // TimerA CKA=Fosc/2 CKB=1 Tout:off
0000A9AC 19 D3 0B 70        	        [P_TimerA_Ctrl] = r1;
0000A9AE 09 93 00 FA        	        r1 = 0xfa00;                    // 8K @ 24.576MHz
                            	        //r1 = 0xfb1d;                  // 8K @ 20MHz
0000A9B0 19 D3 0A 70        	        [P_TimerA_Data] = r1;
0000A9B2 75 92              	        r1 = 0x0035;                    // ADINI should be open (107)
0000A9B3 19 D3 15 70        	        [P_ADC_Ctrl] = r1;
0000A9B5 09 93 A8 00        	        r1 = 0x00A8;                    // Set the DA Ctrl
0000A9B7 19 D3 2A 70        	        [P_DAC_Ctrl] = r1;
                            	        
0000A9B9 09 93 FF FF        	        r1 = 0xffff;
0000A9BB 19 D3 11 70        	        [P_INT_Clear] = r1;          	// Clear interrupt occuiped events
                            	        
0000A9BD 11 93 2D 70        	        r1 = [0x702D]
0000A9BF 09 A3 00 20        	        r1 |= C_FIQ_TMA
0000A9C1 19 D3 2D 70        	        [0x702D] = r1
                            	//        r1 = [R_InterruptStatus]		//
                            	  //      r1 |= C_FIQ_TMA					// Enable Timer A FIQ
                            	    //    [R_InterruptStatus] = r1		//
                            	//        [P_INT_Ctrl] = r1				//
                            	        
0000A9C3 90 9A              	        RETF
                            	
                            	
                            	
                            	F_SP_SACM_DVR_Rec_Init_:					// call by SACM_DVR_Record / SACM_DVR_InitEncoder
0000A9C4 75 92              			r1 = 0x0035;  					//mic input
                            	        //r1 = 0x0037					//line_in input
0000A9C5 19 D3 15 70        	        [P_ADC_Ctrl] = r1;       		//enable ADC
                            	        
0000A9C7 09 93 00 FE        	        r1=0xfe00;                     	//24K @ 24.576MHz
0000A9C9 19 D3 0A 70        	        [P_TimerA_Data] = r1 
0000A9CB 90 9A              			RETF
                            	
                            	F_SP_SACM_DVR_Play_Init_:
0000A9CC 40 92              		    r1 = 0x0000						// call by SACM_DVR_Stop / SACM_DVR_Play
0000A9CD 19 D3 15 70        	        [P_ADC_Ctrl] = r1;       		// Disable ADC
                            	        
0000A9CF 09 93 00 FD        	        r1 = 0xfd00;                	// 16K @ 24.576MHz
0000A9D1 19 D3 0A 70        	        [P_TimerA_Data] = r1;
0000A9D3 90 9A              	        RETF
                            	
                            	
                            	
                            	
                            	/////////////////////////////////////////////////////////////////////////////// 
                            	// Function: Extra Functions provided by Sunplus
                            	//	Type:	
                            	//		1. DAC Ramp up/down
                            	//		2. IO config/import/export
                            	//		3. Get resource data
                            	//
                            	//
                            	///////////////////////////////////////////////////////////////////////////////
                            	
                            	////////////////////////////////////////////////////////
                            	// Function: Ramp Up/Down to avoid speaker "pow" noise
                            	// Destory: R1,R2
                            	////////////////////////////////////////////////////////
                            	_SP_RampUpDAC1:	.PROC
                            	F_SP_RampUpDAC1:
0000A9D4 90 D4              			push r1,r2 to [sp] 
0000A9D5 11 93 17 70        	        r1=[P_DAC1] 
0000A9D7 09 B3 C0 FF        	        r1 &= ~0x003f 
0000A9D9 09 43 00 80        	        cmp     r1,0x8000
0000A9DB 0E 0E              	        jb     	L_RU_NormalUp
0000A9DC 19 5E              	        je      L_RU_End
                            	                
                            	L_RU_DownLoop:
0000A9DD 40 F0 40 AA        	        call    F_Delay         
0000A9DF 41 94              	        r2 = 0x0001 
0000A9E0 1A D5 12 70        	        [P_Watchdog_Clear] = r2 
0000A9E2 09 23 40 00        	        r1 -= 0x40 
0000A9E4 19 D3 17 70        	        [P_DAC1] = r1 
0000A9E6 09 43 00 80        	        cmp     r1,0x8000 
0000A9E8 4C 4E              	        jne     L_RU_DownLoop   
                            	L_RD_DownEnd:
0000A9E9 0C EE              	        jmp     L_RU_End 
                            	
                            	L_RU_NormalUp:
                            	L_RU_Loop:
0000A9EA 40 F0 40 AA        	        call    F_Delay 
0000A9EC 41 94              	        r2 = 0x0001 
0000A9ED 1A D5 12 70        	        [P_Watchdog_Clear] = r2 
0000A9EF 09 03 40 00        	        r1 += 0x40 
0000A9F1 19 D3 17 70        	        [P_DAC1] = r1 
0000A9F3 09 43 00 80        	        cmp     r1, 0x8000 
0000A9F5 4C 4E              	        jne     L_RU_Loop 
                            	L_RU_End:
0000A9F6 90 90              			pop     r1,r2 from [sp] 
0000A9F7 90 9A              	  		retf 
                            	    	.ENDP
                            	    
                            	//............................................................
                            	_SP_RampDnDAC1:	.PROC
                            	F_SP_RampDnDAC1:
0000A9F8 90 D4              			push r1,r2 to [sp] 
                            	  		//int off 
0000A9F9 11 93 17 70        	    	r1 = [P_DAC1] 
0000A9FB 09 B3 C0 FF        	     	r1 &= ~0x003F 
0000A9FD 0A 5E              	      	jz      L_RD_End 
                            	L_RD_Loop:                
0000A9FE 40 F0 40 AA        	        call    F_Delay         
0000AA00 41 94              	        r2 = 0x0001 
0000AA01 1A D5 12 70        	        [P_Watchdog_Clear] = r2 
0000AA03 09 23 40 00        	        r1 -= 0x40 
0000AA05 19 D3 17 70        	        [P_DAC1] = r1   
0000AA07 4A 4E              	        jnz     L_RD_Loop 
                            	L_RD_End:       
                            			//int	fiq,irq
0000AA08 90 90              	        pop     r1,r2 from [sp] 
0000AA09 90 9A              	        retf 
                            			.ENDP
                            	
                            	//..............................................................
                            	_SP_RampUpDAC2:	.PROC
                            	F_SP_RampUpDAC2:
0000AA0A 90 D4              			push r1,r2 to [sp] 
0000AA0B 11 93 16 70        	  		r1=[P_DAC2] 
0000AA0D 09 B3 C0 FF        	    	r1 &= ~0x003f 
0000AA0F 09 43 00 80        	     	cmp     r1,0x8000
0000AA11 0E 0E              	      	jb     	L_RU_NormalUp_   
0000AA12 5D 5E              	       	je      L_RU_End 
                            	                
                            	L_RU_DownLoop_:
0000AA13 40 F0 40 AA        	        call    F_Delay         
0000AA15 41 94              	        r2 = 0x0001 
0000AA16 1A D5 12 70        	        [P_Watchdog_Clear] = r2 
0000AA18 09 23 40 00        	        r1 -= 0x40 
0000AA1A 19 D3 16 70        	        [P_DAC2] = r1 
0000AA1C 09 43 00 80        	        cmp     r1,0x8000 
0000AA1E 4C 4E              	        jne     L_RU_DownLoop_   
                            	L_RD_DownEnd_:
0000AA1F 0C EE              	        jmp     L_RU_End_ 
                            	
                            	L_RU_NormalUp_:
                            	L_RU_Loop_:
0000AA20 40 F0 40 AA        			call    F_Delay 
0000AA22 41 94              	  		r2 = 0x0001 
0000AA23 1A D5 12 70        	    	[P_Watchdog_Clear] = r2 
0000AA25 09 03 40 00        	        r1 += 0x40 
0000AA27 19 D3 16 70        	        [P_DAC2] = r1 
0000AA29 09 43 00 80        	        cmp     r1, 0x8000 
0000AA2B 4C 4E              	        jne     L_RU_Loop_ 
                            	L_RU_End_:
0000AA2C 90 90              	   		pop     r1,r2 from [sp] 
0000AA2D 90 9A              	     	retf 
                            	      	.ENDP
                            	//.............................................................
                            	_SP_RampDnDAC2:	.PROC
                            	F_SP_RampDnDAC2:
                            			//int off 
0000AA2E 90 D4              			push r1,r2 to [sp] 
                            	                
0000AA2F 11 93 16 70        	        r1 = [P_DAC2] 
0000AA31 09 B3 C0 FF        	        r1 &= ~0x003F 
0000AA33 0A 5E              	        jz      L_RD_End_ 
                            	L_RD_Loop_:                
0000AA34 40 F0 40 AA        	        call    F_Delay         
0000AA36 41 94              	        r2 = 0x0001 
0000AA37 1A D5 12 70        	        [P_Watchdog_Clear] = r2 
0000AA39 09 23 40 00        	        r1 -= 0x40 
0000AA3B 19 D3 16 70        	        [P_DAC2] = r1   
0000AA3D 4A 4E              	        jnz     L_RD_Loop_ 
                            	L_RD_End_:       
0000AA3E 90 90              	        pop     r1,r2 from [sp] 
0000AA3F 90 9A              	        retf 
                            			.ENDP
                            	
                            	//..................................................................				
                            	F_Delay:
0000AA40 88 D2              	        push r1 to [sp] 
0000AA41 60 92              	        r1 = C_RampDelayTime			// Ramp Up/Dn delay per step
                            	L_D_Loop:
0000AA42 41 22              	        r1 -= 1 
0000AA43 42 4E              	        jnz     L_D_Loop  
0000AA44 88 90              	        pop     r1 from [sp] 
0000AA45 90 9A              	        RETF	 
                            	
                            	
                            	
                            	////////////////////////////////////////////////////////////////
                            	// Function: I/O Port A configuration
                            	// 	void SP_Inti_IOA(int Dir, int Data, int Attrib)
                            	////////////////////////////////////////////////////////////////
                            	_SP_Init_IOA: .PROC
0000AA46 88 DA              			PUSH bp TO [sp] 
0000AA47 08 0B 01 00        	        bp = sp + 1 
0000AA49 88 D2              			PUSH r1 TO [sp] 
0000AA4A 03 92              			r1 = [bp+3] 						// Port direction
0000AA4B 19 D3 02 70        			[P_IOA_Dir] = r1 
0000AA4D 04 92              			r1 = [bp+4] 
0000AA4E 19 D3 00 70        			[P_IOA_Data] = r1 
0000AA50 05 92              			r1 = [bp+5] 
0000AA51 19 D3 03 70        			[P_IOA_Attrib] = r1 
                            			
0000AA53 88 90              			POP r1 FROM [sp] 
0000AA54 88 98              	        POP bp FROM [sp] 
0000AA55 90 9A              	        RETF 
                            			.ENDP
                            	
                            	////////////////////////////////////////////////////////////////// 
                            	// Function: I/O Port B configuration
                            	//  void SP_Inti_IOB(int Dir, int Data, int Attrib)
                            	//////////////////////////////////////////////////////////////////    
                            	_SP_Init_IOB: .PROC
0000AA56 88 DA              			PUSH bp TO [sp] 
0000AA57 08 0B 01 00        	        bp = sp + 1 
0000AA59 88 D2              			PUSH r1 TO [sp] 
0000AA5A 03 92              			r1 = [bp+3] 						// Port direction
0000AA5B 19 D3 07 70        			[P_IOB_Dir] = r1 
0000AA5D 04 92              			r1 = [bp+4] 
0000AA5E 19 D3 05 70        			[P_IOB_Data] = r1 
0000AA60 05 92              			r1 = [bp+5] 
0000AA61 19 D3 08 70        			[P_IOB_Attrib] = r1 
                            			
0000AA63 88 90              			POP r1 FROM [sp] 
0000AA64 88 98              	        POP bp FROM [sp] 
0000AA65 90 9A              	        RETF 
                            			.ENDP
                            	
                            	////////////////////////////////////////////////////////////////// 
                            	// Function: Get data from port
                            	// 	int SP_Import(unsigned int Port)
                            	//////////////////////////////////////////////////////////////////  
                            	_SP_Import: .PROC
0000AA66 88 DA              	        PUSH bp TO [sp] 
0000AA67 08 0B 01 00        	        bp = sp + 1 
                            	        
0000AA69 03 92              			r1 = [bp+3]  						// Port Number
0000AA6A C1 92              			r1 = [r1]  
                            					
0000AA6B 88 98              	        POP bp FROM [sp] 
0000AA6C 90 9A              	        RETF 
                            			.ENDP
                            	
                            	_SP_Export: .PROC
0000AA6D 88 DA              	        PUSH bp,bp TO [sp] 
0000AA6E 41 00              	        sp = sp + 1 
0000AA6F 90 D4              			PUSH r1,r2 TO [sp] 
0000AA70 03 92              			r1 = [bp+3]  						// Port Number
0000AA71 04 94              			r2 = [bp+4]  						// Value
0000AA72 C1 D4              			[r1] = r2  
0000AA73 90 90              			POP r1,r2 FROM [sp] 
0000AA74 88 98              	        POP bp,bp FROM [sp] 
0000AA75 90 9A              	        RETF         
                            	 		.ENDP
                            	
                            	
                            	////////////////////////////////////////////////////////////////// 
                            	// Function: Get data from resource(ROM area)
                            	// 	int SP_GetResource(int Addr, int Page)
                            	//////////////////////////////////////////////////////////////////  
                            	_SP_GetResource:	.PROC
0000AA76 88 DA              			push bp to [sp] 
0000AA77 08 0B 01 00        			bp = sp + 1 
                            			
0000AA79 03 92              			r1 = [bp+3] 					// Address
0000AA7A 04 94              			r2 = [bp+4] 					// Page
                            			
0000AA7B 5A 95              			r2 = r2 lsl 4 					// Prepare Page for SR
0000AA7C 5A 95              			r2 = r2 lsl 4 
0000AA7D 4A 95              			r2 = r2 lsl 2 
                            			
0000AA7E 7F BC              			sr &= 0x03f 					// Change Page
0000AA7F 06 A5              	        r2 |=sr 						//
0000AA80 02 9D              	        sr = r2 						//
                            	  
0000AA81 E1 92              	  		r1 = D:[r1] 					// Get data
                            	       
0000AA82 88 98              			pop	 bp from [sp] 
0000AA83 90 9A              			retf 
                            			.ENDP 
                            	//........................................
                            	F_SP_GetResource:
0000AA84 5A 95              			r2 = r2 lsl 4 					// Prepare Page for SR
0000AA85 5A 95              			r2 = r2 lsl 4 
0000AA86 4A 95              			r2 = r2 lsl 2 
                            			
0000AA87 7F BC              			sr &= 0x03f 					// Change Page
0000AA88 06 A5              	        r2 |=sr 						//
0000AA89 02 9D              	        sr = r2 						//
                            	  
0000AA8A E1 92              	  		r1 = D:[r1] 					// Get data
0000AA8B 90 9A              		  	retf
                            	
                            	//////////////////////////////////////////////////////////////////
                            	// Functions: Reserve old defintion
                            	// Note: 	1. Some user who use old library may use the old name
                            	//			2. Have to be put at the end of this file
                            	//////////////////////////////////////////////////////////////////
                            	.PUBLIC	F_RampUpDAC1 
                            	.PUBLIC	F_RampDnDAC1 
                            	.PUBLIC	F_RampUpDAC2 
                            	.PUBLIC	F_RampDnDAC2 
                            	.PUBLIC	_STD_RampUpDAC1 
                            	.PUBLIC	_STD_RampDnDAC1 
                            	.PUBLIC	_STD_RampUpDAC2 
                            	.PUBLIC	_STD_RampDnDAC2 
                            	
                            	.DEFINE F_RampUpDAC1 F_SP_RampUpDAC1
                            	.DEFINE F_RampDnDAC1 F_SP_RampDnDAC1
                            	.DEFINE F_RampUpDAC2 F_SP_RampUpDAC2
                            	.DEFINE F_RampDnDAC2 F_SP_RampDnDAC2
                            	.DEFINE _STD_RampUpDAC1 _SP_RampUpDAC1
                            	.DEFINE _STD_RampDnDAC1 _SP_RampDnDAC1
                            	.DEFINE _STD_RampUpDAC2 _SP_RampUpDAC2
                            	.DEFINE _STD_RampDnDAC2 _SP_RampDnDAC2
                            	
                            	
                            	///////////////////////////////////////////////////////////////////
                            	                
                            	//========================================================================================        
                            	// End of hardware.asm
                            	//========================================================================================
                            	
                            	
                            	
                            	        
                            	        
                            	        
0 error(s), 0 warning(s).



























